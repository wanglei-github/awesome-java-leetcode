# 动态规划
首先需要识别动态规划问题[知乎](https://www.zhihu.com/question/23995189)，从链接看出，一般包含一下两个特性可以确定为dp问题

1. 无后性（如果给定某一阶段的状态，则在这一阶段以后过程的发展不受这阶段以前各段状态的影响）
2. 最优子问题性

最优子问题性好理解，例如746这题，想要知道最小消耗可以从最后一次选择考虑，即，我要跳完的话，
可能在最后有两种选择，即要么从**最后-1（n-1）**个，要么从**最后-2(n-2)**个跳到最后。ok，想到这里，
可以能够大体有个转移方程的概念（转移方程也可以理解为dp的特性）。
但是无后性，还是没法很深入的了解，可以简单理解为，最后一次选择，只和这次选择有关，之前的选择（已经确定为最优了），
我只要做好这次选择即可（选择从 n-1或者n-2 过）。

## dp问题三步

1. 我是谁（```dp[i]```的含义）
2. 我来自哪里（```dp[i]```的转移方程）
3. 我要去哪里（```dp[i]```最终求解）


## 确定转移方程
在确定转移方程时，有比较大理解问题，一定要明确点```dp[i]```的概念。
最早的转移方程式为
```
dp[i] = Math.min(dp[i - 2]+cost[i-2], dp[i - 1] + cost[i-1])
```
当时的理解是 ```dp[i]```为在到达i台阶所需要最小的消耗cost，
最后的 ```return``` 也为 
``` return  Math.min(dp[length-2]+cost[i-2], dp[length-1] + cost[i-1])
```
此时，所求得值为，到n-2 和 n-1 的最优解，确不是n的最优解。由于转移方程的概念有问题，
致使 ```dp[0]``` 和 ```dp[1]``` 求解也有问题。

再次回到转移方程的确认上，```dp[i]``` 若为经历i台阶所需要消耗的最优值，那么最后的
```return``` 就可以是 ```Math.min(dp[length-1],dp[length-2])```。
因为，到达顶点就两种选择，一种从n-1直接走，一种是从n-2跳过n-1直接到，至此，问题得到解决。

则转移方程为
```
dp[i]=Math.min(dp[i-1],dp[i-2])+cost[i]
```
则```dp[0]=cost[0];dp[1]=cost[1]```

# 总结dp问题

1. 最优解问题考虑dp
2. 是否会有重复的计算，（朴素穷举必然导致时间复杂度上升）
3. 是有可以用转移方程解决问题
4. 确认好```dp[i]```的正确含义