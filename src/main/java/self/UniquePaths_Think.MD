# UniquePaths
  最初想法是按深度遍历，每个节点都会有分支，选用了node节点的方式（first_commit_record），
  算法实现简单，也觉得会有重复的节点数据入栈，但是没有考虑太多。
  在MxN量级较小的情况下，顺利输出。
  当MxN量级增大时（7x3时，需要1分钟左右），时间过慢，认定由于重复节点入栈太多导致。***时间复杂度猜测为O(n^2)***
  后来考虑使用visted的思想，将已经遍历的节点不再入栈，直接计算path路径（遇到已遍历的节点就path++）。
  但，问题出现了对于已出现的节点visted次数和path总数计算上。无法准确计算某一个节点的visted的 数量和path的量。
  顾尝试从后面节点往前尝试思考。
  通过2x2、3x3等再终极节点尝试找到path计算的规律。（3x3时，围绕终极节点的3个节点，左、上、左上都说是2，3x3为6）
  
  中间也有过继承累加的思想，但那个时候被困在 node节点形式（在出现复杂度问题时，开始放弃这种node节点方式，于是思考能不能
  直接使用数组遍历来完成）。
  
  最后重新从头节点开始，以某个节点有几种路过的方式，来计算终极节点的方式。
  两条边肯定都会经过且一次。但int[1][1]、int[1][2]这样有几次呢？
  后续，便找到了解决方案。 
  